# 13.10 复习题

## 1.派生类从基类那里继承了什么？

继承了基类的公有方法、私有数据成员和保护数据成员，然而私有数据成员只能通过基类的公有方法访问。



## 2.派生类不能从基类那里继承什么？

不能继承基类的构造函数、析构函数、友元函数以及私有方法。



## 3.假设baseDMA ::operator=( )函数的返回类型为void，而不是 baseDMA &，这将有什么后果？如果返回类型为baseDMA，而不是baseDMA &，又将有什么后果？

1. 将不能进行连续赋值，即`a=b=c`将不能实现。
2. 编译器将创建副本，从而增大开销。



## 4.创建和删除派生类对象时，构造函数和析构函数调用的顺序是怎样的？

1. 创建派生类对象时，将首先创建基类对象（调用基类的构造函数），然后创建派生类对象（调用派生类的构造函数）。
2. 删除派生类对象时，将首先调用派生类的析构函数，然后自动调用基类的析构函数。



## 5.如果派生类没有添加任何数据成员，它是否需要构造函数？ 

需要。因为基类对象在进入派生类构造函数前被创建，因此需要显式定义派生类构造函数。



## 6.如果基类和派生类定义了同名的方法，当派生类对象调用该方法时，被调用的将是哪个方法？ 

调用的是派生类的版本。



## 7.在什么情况下，派生类应定义赋值运算符？ 

派生类新增的数据成员使用了`new`来分配内存时。



## 8.可以将派生类对象的地址赋给基类指针吗？可以将基类对象的地址赋给派生类指针吗？ 

无需强制转换便可把派生类对象的地址赋给基类指针；将基类对象的地址赋给派生类指针需要显式强制转换：

```c++
base& (derived&);//比较明显的强制转换
dynamic_cast<base&> derived&;//比较安全的强制转换
```



## 9.可以将派生类对象赋给基类对象吗？可以将基类对象赋给派生类对象吗？

1. 将派生类对象赋给基类对象时，会将派生类内嵌的基类对象赋给要赋值的基类对象。
2. 不能把基类对象赋给派生类对象。



## 10.假设定义了一个函数，它将基类对象的引用作为参数。为什么该函数也可以将派生类对象作为参数？ 

因为基类引用可以指向派生类对象，无需显式转换。



## 11.假设定义了一个函数，它将基类对象作为参数（即函数按值传递基类对象）。为什么该函数也可以将派生类对象作为参数？ 

因为可以把派生类对象赋值给基类对象。



## 12.为什么通常按引用传递对象比按值传递对象的效率更高？ 

按值传递对象时，编译器将创建副本，增大开销；按引用传递对象时，直接传递当前要传递对象的地址，不会增大开销。



## 13.假设Corporation是基类，PublicCorporation是派生类。再假设这两个类都定义了head( )函数，ph是指向Corporation类型的指针，且被赋给了一个PublicCorporation对象的地址。如果基类将head( )定义为：a．常规非虚方法；b．虚方法；则ph->head( )将被如何解释？

1.  将使用`Corporation::head()`，常规非虚方法将根据指针类型判断调用的版本。
2. 将使用`PublicCorporation::head()`，虚方法将根据指针指向的对象的类型判断调用的版本。



## 14.下述代码有什么问题？

```c++
class Kitchen{
private:
    double kit_sq_ft;
public:
    Kitchen(){kit_sq_ft=0.0;}
    virtual double area()const{return kit_sq_fit*kit_sq_fit;}
};
class House:public Kitchen{
private:
    double all_sq_ft;
public:
    House(){all_sq_ft+=kit_sq_ft;}
    double area(const char* s)const{cout<<s;return all_sq_ft;}
}
```





















